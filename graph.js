var width = 800,
    height = 500;

var force = d3.layout.force()
  .size([width, height])
  .charge(-400)
  .linkDistance(60)
  .on("tick", tick);

var svg = d3.select("body").append("svg")
  .attr("id", "canvas")
  .attr("width", width)
  .attr("height", height);

var link = svg.selectAll(".link"),
    node = svg.selectAll(".node");

function tick() {
}

function getIndex(nodes, id) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].id == id)
      return i;
  }
}

// transform the coordinates from the JSON file to meaningful coordinates on the canvas
function transform(x, y) {
  return [200 + 100 * x, height / 2 - 100 * y]; // TODO make this an object with .x and .y?
}

d3.json("format.json", function(error, graph) {
  console.log(error);

  // process the links to the D3 format with indices
  for (var i = 0; i < graph.links.length; i++) { // TODO can be improved using the preprocessing used later
    graph.links[i].target = getIndex(graph.nodes, graph.links[i].coarser)
    graph.links[i].source = getIndex(graph.nodes, graph.links[i].finer)
  }

  // make sure the force-directedness is turned off
  for (var i = 0; i < graph.nodes.length; i++)
    graph.nodes[i].fixed = true;

  var topologies = [];

  // preprocess the topologies for easier access
  for (var i = 0; i < graph.nodes.length; i++)
    topologies[graph.nodes[i].id] = graph.nodes[i];

  // process the relations between topologies
  for (id in topologies) {
    // we look for all finer topologies
    var finer = [id];
    topologies[id].finer = [];

    while (finer.length > 0) {
      topology = finer.pop();

      for (var i = 0; i < graph.links.length; i++) {
        if (graph.links[i].coarser == topology) {
          if (topologies[id].finer.indexOf(graph.links[i].finer) == -1)
            topologies[id].finer.push(graph.links[i].finer);

          finer.push(graph.links[i].finer)
        }
      }
    }

    // we look for all coarser topologies
    var coarser = [id];
    topologies[id].coarser = [];

    while (coarser.length > 0) {
      topology = coarser.pop();

      for (var i = 0; i < graph.links.length; i++) {
        if (graph.links[i].finer == topology) {
          if (topologies[id].coarser.indexOf(graph.links[i].coarser) == -1)
            topologies[id].coarser.push(graph.links[i].coarser);

          coarser.push(graph.links[i].coarser)
        }
      }
    }
  }

  console.log(topologies);

  // create the passports for each topology
  for (id in topologies) {
    var topology = topologies[id];

    var passport = $("<div class='passport' id='" + topology.id + "'></div>");
    passport.append("<h2><span class='symbol'>$" + topology.symbol + "$</span> " + topology.name + "</h2>");

    var dl = $("<dl></dl>");
    if ("generated" in topology) {
      dl.append("<dt>generated by");
      dl.append("<dd>" + topology.generated);
    }
    if ("refining" in topology) {
      dl.append("<dt>refining</dt>");
      dl.append("<dd>" + topology.refining); // TODO use MathJax here (not SVG, so okay)
    }

    function createComparisonList(topology, list) {
      var ul = $("<ul class='comparison-list'></ul>");
      for (var j = 0; j < list.length; j++)
        ul.append("<li><a href='#'>" + list[j] + "</a>"); // TODO display both abbreviation and full name, or at least the symbol (= use MathJax)

      return ul;
    }

    dl.append("<dt>coarser than</dt>");
    if (topology.finer.length == 0) // I admit, this is a confusing name
      dl.append("<dd><span class='nothing'>nothing</span>");
    else 
      dl.append($("<dd>").append(createComparisonList(topology, topology.finer)));

    dl.append("<dt>finer than</dt>");
    if (topology.coarser.length == 0) // I admit, this is a confusing name
      dl.append("<dd><span class='nothing'>nothing</span>");
    else 
      dl.append($("<dd>").append(createComparisonList(topology, topology.coarser)));

    dl.appendTo(passport);
    
    passport.appendTo("body");
  }
  
  MathJax.Hub.Queue(["Typeset", MathJax.Hub]);

  force
    .nodes(graph.nodes)
    .links(graph.links)
    .start();

  link = link.data(graph.links)
    .enter().append("line")
    .attr("class", "link")
    .attr("x1", function(d) { return transform(d.source.x, d.source.y)[0] + "px"; })
    .attr("y1", function(d) { return transform(d.source.x, d.source.y)[1] + "px"; })
    .attr("x2", function(d) { return transform(d.target.x, d.target.y)[0] + "px"; })
    .attr("y2", function(d) { return transform(d.target.x, d.target.y)[1] + "px"; })

  node = node.data(graph.nodes)
    .enter().append("circle")
    .attr("class", "node")
    .attr("r", 5)
    .attr("cx", function(d) { return transform(d.x, d.y)[0] + "px"; })
    .attr("cy", function(d) { return transform(d.x, d.y)[1] + "px"; })
    .attr("fixed", "true");

  text = svg.append("g").selectAll("text")
    .data(force.nodes())
    .enter().append("text")
    .attr("x", function(d) { return transform(d.x, d.y)[0] + "px"; })
    .attr("y", function(d) { return transform(d.x, d.y)[1] + "px"; })
    .text(function(d) { return d.id }); // TODO it seems to be hard to use MathJax inside SVG...

  //MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
});

